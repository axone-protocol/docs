"use strict";(self.webpackChunk_okp4_docs=self.webpackChunk_okp4_docs||[]).push([[70832],{13811:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>m,frontMatter:()=>c,metadata:()=>d,readingTime:()=>u,toc:()=>p});var i=s(85893),r=s(11151),t=s(41756);const a=JSON.parse('{"quizTitle":"Test your knowledge!","nrOfQuestions":"4","questions":[{"question":"Which of the following best describes the role of Prolog in the Axone protocol?","questionType":"text","answerSelectionType":"single","answers":["Prolog is primarily used for front-end development within the Axone ecosystem, focusing on user interface design and experience.","Prolog serves as a database management system in Axone, handling the storage, retrieval, and update of data within the protocol.","Prolog is employed as an on-chain module within Axone, interpreting rules related to governance and consent, and ensuring secure and reliable decentralized decision-making.","Prolog functions as a cryptocurrency wallet in the Axone protocol, managing digital assets and facilitating transactions between users."],"correctAnswer":"3","messageForCorrectAnswer":"Correct answer. Good job.","messageForIncorrectAnswer":"Incorrect answer. Please try again.","point":"1"},{"question":"How does the Axone protocol handle the dynamic nature of resource management?","questionType":"text","answerSelectionType":"single","answers":["By enforcing static rules.","Through Dynamic Rule Updates in real-time.","By allowing only manual updates to rules.","By relying on a centralized system for adaptation."],"correctAnswer":"2","messageForCorrectAnswer":"Correct answer. Good job.","messageForIncorrectAnswer":"Incorrect answer. Please try again.","point":"1"},{"question":"What is the role of hierarchy of norms in Axone resource consents?","questionType":"text","answerSelectionType":"single","answers":["It establishes the order of precedence among different norms.","It increases transparency.","It eliminates conflicts.","It enforces static rules."],"correctAnswer":"1","messageForCorrectAnswer":"Correct answer. Good job.","messageForIncorrectAnswer":"Incorrect answer. Please try again.","point":"1"},{"question":"In Prolog, what is the declarative style?","questionType":"text","answerSelectionType":"single","answers":["Specifying how to achieve a task","Describing relationships and rules without step-by-step instructions.","Focusing on sequential programming.","Ignoring logical inferenceIt establishes the order of precedence among different norms."],"correctAnswer":"2","messageForCorrectAnswer":"Correct answer. Good job.","messageForIncorrectAnswer":"Incorrect answer. Please try again.","point":"1"}]}');var o=s.t(a,2);const c={sidebar_position:2},l="Define any rule",d={id:"academy/part-1/rules",title:"Define any rule",description:"Reading time:  min",source:"@site/docs/academy/part-1/rules.mdx",sourceDirName:"academy/part-1",slug:"/academy/part-1/rules",permalink:"/fr/academy/part-1/rules",draft:!1,unlisted:!1,editUrl:"https://github.com/okp4/docs/edit/main/docs/academy/part-1/rules.mdx",tags:[],version:"current",lastUpdatedAt:1709882506e3,sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"academy",previous:{title:"Resources: what can be shared",permalink:"/fr/academy/part-1/resources"},next:{title:"Consume resources",permalink:"/fr/academy/part-1/consume-resources"}},h={},u=12,p=[{value:"Rules: what can be defined?",id:"rules-what-can-be-defined",level:2},{value:"1. Defining Access Permissions",id:"1-defining-access-permissions",level:3},{value:"2. Resource Utilization Policies",id:"2-resource-utilization-policies",level:3},{value:"3. Business models",id:"3-business-models",level:3},{value:"4. Dynamic Rule Updates",id:"4-dynamic-rule-updates",level:3},{value:"5. Inter-Rule Relationships",id:"5-inter-rule-relationships",level:3},{value:"Prolog: Turing complete logical and declarative programming language",id:"prolog-turing-complete-logical-and-declarative-programming-language",level:2},{value:"1. The Essence of Prolog",id:"1-the-essence-of-prolog",level:3},{value:"2. Turing Completeness",id:"2-turing-completeness",level:3},{value:"3. Declarative Programming in Action",id:"3-declarative-programming-in-action",level:3},{value:"4. Logical Problem Solving",id:"4-logical-problem-solving",level:3},{value:"5. Decentralized Interpretation",id:"5-decentralized-interpretation",level:3},{value:"6. Prolog in practice",id:"6-prolog-in-practice",level:3},{value:"Resource&#39;s consents",id:"resources-consents",level:2}];function g(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"define-any-rule",children:"Define any rule"}),"\n",(0,i.jsxs)("i",{children:["Reading time: ",u," min"]}),"\n",(0,i.jsx)(n.h2,{id:"rules-what-can-be-defined",children:"Rules: what can be defined?"}),"\n",(0,i.jsxs)(n.p,{children:["The key feature of the Axone protocol is the ability to define rules within its ecosystem. The term ",(0,i.jsx)(n.strong,{children:'"Rules"'})," forms the backbone of the protocol, governing how off-chain digital resources like datasets, algorithms, storage, and computation resources are shared and managed. These rules define the parameters and conditions under which resource sharing and interactions occur. Understanding the scope of what can be defined within these rules is crucial for harnessing the full power of the Axone protocol."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"https://docs.okp4.network/whitepaper/solution#zone-overview",children:"zone"})," is a conceptual framework defined by a set of rules, within which the recognized digital resources are compatible with these rules, considering the associated consents. A resource is not attached to a zone. The recognition of resources within a Zone relies on the dynamic evaluation of the conformity of the rules and consents of the resources."]}),"\n",(0,i.jsx)(n.p,{children:"The Axone protocol enforces rules for governance and consent. When users want to do something in a Zone (launch a workflow to create new indicators or train an AI model, for instance), the protocol checks if it's allowed based on the rules. This decision considers the current situation, as blockchain rules and digital resources constantly change. From a computer science perspective, the challenge is dealing with complex logic involving rules, such as hierarchy, inconsistency, and dependency.\nTo handle this, the Axone protocol ensures a secure and reliable way to interpret rules in a decentralized manner. The rules in each Zone and the consent attached to a resource determine if a user's action is permitted. It's essential to remember that this assessment also considers the evolving state of the blockchain at the time of the request."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rules-1",src:s(15251).Z+"",width:"1494",height:"736"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"An Identity (human or bot) wants to interact with a Zone"}),"\n",(0,i.jsx)(n.li,{children:"The Zone asks the dedicated smart contract if it's possible given the context and all the involved rules"}),"\n",(0,i.jsx)(n.li,{children:"The protocol employs logical inference to resolve matters based on the state of the blockchain"}),"\n",(0,i.jsx)(n.li,{children:'The protocol yields a modality as a response, such as "prohibited", "permitted", "possible", and so on. Depending on the answer, the execution process could start.'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"What kind of rules can be defined?"}),"\n",(0,i.jsx)(n.h3,{id:"1-defining-access-permissions",children:"1. Defining Access Permissions"}),"\n",(0,i.jsx)(n.p,{children:"One fundamental aspect of Axone rules is the ability to define access permissions. Through these rules, you can precisely outline who has the right to access specific off-chain resources. Whether granting read-only access to certain data or complete control over a particular resource, Axone empowers users to tailor access permissions according to their unique needs."}),"\n",(0,i.jsx)(n.h3,{id:"2-resource-utilization-policies",children:"2. Resource Utilization Policies"}),"\n",(0,i.jsx)(n.p,{children:"Axone allows users to establish resource utilization policies beyond simple access permissions. This involves defining how shared resources can be utilized, ensuring optimal efficiency, and preventing misuse. Whether specifying the duration of resource access or setting usage quotas, Axone rules provide a flexible framework for resource management. For example, users can define temporal and spatial constraints for resource sharing. This means you can set rules that dictate when specific resources are available, creating dynamic access schedules. Additionally, spatial constraints enable the restriction of resource access based on geographical or network-specific parameters."}),"\n",(0,i.jsx)(n.h3,{id:"3-business-models",children:"3. Business models"}),"\n",(0,i.jsx)(n.p,{children:"Each zone can define how value is created and distributed among participants. This could range from straightforward transaction-based models to more complex, performance-based incentives."}),"\n",(0,i.jsx)(n.h3,{id:"4-dynamic-rule-updates",children:"4. Dynamic Rule Updates"}),"\n",(0,i.jsx)(n.p,{children:"The Axone protocol acknowledges the dynamic nature of resource management. Rules can be updated in real-time, enabling users to adapt to changing requirements seamlessly. This dynamicity ensures that Axone remains responsive to evolving scenarios, providing a future-proof solution for off-chain resource orchestration."}),"\n",(0,i.jsx)(n.h3,{id:"5-inter-rule-relationships",children:"5. Inter-Rule Relationships"}),"\n",(0,i.jsx)(n.p,{children:"Axone rules are not isolated entities; they can interact with one another. Understanding and defining inter-rule relationships is a powerful aspect of Axone's flexibility. For example, you can establish dependencies between rules, ensuring that certain conditions must be met before others come into effect."}),"\n",(0,i.jsx)(n.p,{children:"The ability to define rules is a pivotal feature of the Axone protocol, offering an unprecedented level of control and customization. By leveraging these rules, participants can create diverse applications and ecosystems, each with unique governance and operational dynamics. This flexibility is central to Axone's vision of fostering a decentralized, collaborative, and innovative digital resource environment."}),"\n",(0,i.jsx)(n.h2,{id:"prolog-turing-complete-logical-and-declarative-programming-language",children:"Prolog: Turing complete logical and declarative programming language"}),"\n",(0,i.jsx)(n.p,{children:"In the vast landscape of programming languages, Prolog stands out as a formidable tool. And in the realm of Axone, it plays a pivotal role in shaping the logical and declarative aspects of the protocol. Prolog's significance lies in its ability to handle complex logical scenarios, making it a powerful choice for the dynamic environment of the Axone protocol."}),"\n",(0,i.jsx)(n.h3,{id:"1-the-essence-of-prolog",children:"1. The Essence of Prolog"}),"\n",(0,i.jsx)(n.p,{children:'Prolog, short for "Programming in Logic," is a unique programming paradigm that utilizes logical inference and declarative statements. Unlike traditional imperative languages, Prolog focuses on describing relationships and rules rather than explicit step-by-step instructions. This makes it well-suited for expressing complex relationships and solving intricate logical problems, precisely the challenges faced in Axone.'}),"\n",(0,i.jsx)(n.h3,{id:"2-turing-completeness",children:"2. Turing Completeness"}),"\n",(0,i.jsx)(n.p,{children:"One of Prolog's notable features is its Turing completeness. This term signifies that Prolog can, in theory, compute anything computable by other programming languages. This attribute is essential for Axone, as it ensures that the logical and declarative programming capabilities provided by Prolog can address the diverse and evolving challenges presented by combining multiple resources and rules."}),"\n",(0,i.jsx)(n.h3,{id:"3-declarative-programming-in-action",children:"3. Declarative Programming in Action"}),"\n",(0,i.jsx)(n.p,{children:"In the context of Axone, Prolog's declarative nature is a boon. Users can specify what they want to achieve, and Prolog handles the intricate task of determining how to achieve it. This provides a clear and concise way to express the governance and consent rules governing resource interactions."}),"\n",(0,i.jsx)(n.h3,{id:"4-logical-problem-solving",children:"4. Logical Problem Solving"}),"\n",(0,i.jsx)(n.p,{children:"The dynamic and evolving nature of Axone's rules necessitates a robust logical problem-solving capability. Prolog excels in this arena by employing a resolution-based inference engine, allowing it to navigate through complex relationships defined by rules. This becomes crucial when resolving issues of hierarchy, inconsistency, dependency, and conflict resolution in access permissions and resource utilization."}),"\n",(0,i.jsx)(n.h3,{id:"5-decentralized-interpretation",children:"5. Decentralized Interpretation"}),"\n",(0,i.jsx)(n.p,{children:"In the Axone ecosystem, where decentralization is a crucial principle, Prolog is integrated into an on-chain module and serves as a trustworthy interpreter of rules. With its established rules, each Zone can leverage Prolog to determine the permissibility of a user's actions. This decentralized interpretation ensures that the governance and consent rules are applied consistently and reliably across the network."}),"\n",(0,i.jsx)(n.h3,{id:"6-prolog-in-practice",children:"6. Prolog in practice"}),"\n",(0,i.jsx)(n.p,{children:"Here are some fundamental concepts and basics of the Prolog language:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Declarative Style"}),":\nProlog is a declarative language, meaning that you specify what you want to achieve rather than how to achieve it. Programs in Prolog describe relationships and rules rather than a sequence of steps."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Logic Programming"}),":\nProlog is a logic programming language. It is based on the principles of first-order logic, where statements are represented as logical predicates."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)("u",{children:"Facts and Rules"}),":\nProlog programs consist of facts and rules. Facts are statements about the world, and rules define relationships and conditions. These are the building blocks for creating a knowledge base."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Fact\n% John likes pizza.\nlikes(john, pizza).\n\n% Rule\n% X is hungry IF X likes pizza. \nhungry(X) :- likes(X, pizza).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Predicates and Clauses"}),":\nIn Prolog, statements are expressed as predicates. Predicates consist of a function (name) and arguments. Clauses are the combination of facts and rules."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Predicate\nlikes(john, pizza).\n\n% Clause (fact)\nfather(john, jim).\n\n% Clause (rule)\nsibling(X, Y) :- father(Z, X), father(Z, Y), X \\= Y.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Variables"}),":\nProlog uses variables to represent unknown values. Variables are denoted with a capital letter or an underscore."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Variable\n% John likes X.\nlikes(john, X).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Queries"}),":\nProlog is interactive, and users can query the knowledge base. The system will attempt to find values for variables that satisfy the given conditions."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Query\n% What does John like?\n?- likes(john, What).\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Backtracking"}),":\nProlog uses a backtracking mechanism to explore alternative solutions. If a query fails, Prolog will backtrack and explore other possibilities."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Backtracking example\n% The following rule defines a family relationship.\nparent(john, jim).\nparent(john, ann).\nparent(jim, tom).\n\n% Query: Who is Tom's parent?\n?- parent(X, tom). \n% This will return X = jim, and upon backtracking, X = john.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Recursion"}),":\nProlog supports recursion, allowing functions to call themselves. Recursive structures are common in Prolog for expressing relationships that involve repetition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Recursive rule for factorial\nfactorial(0, 1):-!.\nfactorial(N, Result) :- N > 0, Prev is N - 1, factorial(Prev, PrevResult), Result is N * PrevResult.\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)("u",{children:"Cut Operator (!)"}),":\nThe cut operator controls backtracking. It prunes the search space and commits Prolog to the choices made."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Cut operator example\nlikes(john, pizza).\nlikes(john, sushi).\n\n% Query: Does John like pizza?\n?- likes(john, pizza), !.\n"})}),"\n",(0,i.jsx)(n.p,{children:"These are some of the basic concepts of Prolog. Its emphasis on logic and declarative programming makes it well-suited for rule-based systems, knowledge representation, and artificial intelligence applications."}),"\n",(0,i.jsx)(n.p,{children:"As we progress through the Axone Academy, the role of Prolog becomes increasingly apparent in enabling a Turing complete, logical, and declarative approach to managing the intricate rules that define the protocol. Join us on this journey as we explore the depth of Prolog's capabilities within the dynamic landscape of Axone."}),"\n",(0,i.jsx)(n.h2,{id:"resources-consents",children:"Resource's consents"}),"\n",(0,i.jsx)(n.p,{children:"In the intricate web of the Axone protocol, the heartbeat of interaction lies within the rules governing each resource, also called consents. Understanding how these rules are defined and implemented is crucial for harnessing the true potential of Axone's off-chain resource sharing."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Defining Resource-Specific Rules"})}),"\n",(0,i.jsx)(n.p,{children:"Every resource within the Axone ecosystem comes with its consent, a set of rules intricately defining how it can be accessed, utilized, and shared. These rules act as the blueprint for the resource's behavior, outlining the conditions under which it can be interacted with. Whether it's data, computational power, or any other off-chain asset, the rules are the guiding principles for their governance."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Access Permissions and Restrictions"})}),"\n",(0,i.jsx)(n.p,{children:"At the core of resource consents are access permissions and restrictions. Axone allows resource owners to precisely dictate who can access their resources and under what circumstances. This includes specifying read or write permissions, setting limitations on the duration of access, and defining the geographical or network-based constraints for interaction. Such fine-grained control ensures that resource owners maintain sovereignty over their assets."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Resource Utilization Policies"})}),"\n",(0,i.jsx)(n.p,{children:"Beyond mere access, Axone resource consents extend to resource utilization policies. Owners can define how their resources should be utilized by setting usage quotas, determining the conditions for resource sharing, or specifying the acceptable purposes for interaction. These policies contribute to the efficient and controlled utilization of resources within the decentralized Axone network."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Dynamic Rule Adaptation"})}),"\n",(0,i.jsx)(n.p,{children:"Consents in Axone are not static; they adapt dynamically to the changing needs of the ecosystem. As conditions evolve, resource owners can update rules in real-time, ensuring that their assets remain responsive to the ever-shifting landscape of off-chain resource sharing. This dynamic adaptability is a key feature that aligns Axone with the fluid nature of decentralized networks."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Rule Interdependencies and Conflicts"})}),"\n",(0,i.jsx)(n.p,{children:"Given the interconnected nature of resources and their rules, Axone acknowledges the potential for interdependencies and conflicts. The hierarchy of norms refers to the hierarchical structure of rules within the Axone governance framework. It establishes the order of precedence among the different norms so that a higher norm prevails over a lower standard. Then, the rules of a Zone prevail on the resource consent (see technical doc)."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"rules-2",src:s(48845).Z+"",width:"1400",height:"657"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"6. Transparency and Auditing"})}),"\n",(0,i.jsx)(n.p,{children:"Axone places a premium on transparency in resource governance. Resource consents are designed to be transparent and auditable, allowing users and stakeholders to understand how each resource is governed.  This transparency fosters trust and contributes to the overall security and accountability within the Axone ecosystem."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"7. Let's practice"})}),"\n",(0,i.jsx)(n.p,{children:"Let's consider a simple example of rules written in Prolog for a hypothetical resource-sharing scenario within the Axone context. In this example, we'll create rules for granting access to a specific dataset based on user roles and temporal constraints."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-prolog",children:"% Define roles\nrole(admin).\nrole(user).\nrole(guest).\n\n% Define users and their roles\nuser_role(john, admin).\nuser_role(susan, user).\nuser_role(bob, guest).\n\n% Define access rules based on roles and time\naccess_rule(admin, Dataset, _):- dataset(Dataset).\naccess_rule(user, Dataset, Time):- dataset(Dataset), current_time(Time), Time < 18.00.\naccess_rule(guest, public_data, _).\n\n% Define the dataset\ndataset(confidential_data).\ndataset(public_data).\n\n% Simulate the current time (for illustration purposes)\ncurrent_time(15.30).\n\n% Example queries\n% Query: Can John access the confidential_data dataset at the current time?\n% Result: Yes, because John is an admin, and there's no temporal constraint for admins.\n?- user_role(john, Role), access_rule(Role, confidential_data, Time).\n\n% Query: Can Susan access the confidential_data dataset at the current time?\n% Result: Yes, because Susan is a user, and the current time is before 18.00.\n?- user_role(susan, Role), access_rule(Role, confidential_data, Time).\n\n% Query: Can Bob access the confidential_data dataset at the current time?\n% Result: No, because Bob is a guest, and the dataset is confidential with no specified temporal constraint for guests.\n?- user_role(bob, Role), access_rule(Role, confidential_data, Time).\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this Prolog example, we define roles (admin, user, guest) and associate users with roles.\nAccess rules are determined based on roles and, in some cases, temporal constraints. For instance, admins have unrestricted access to any dataset, users have access before 18.00, and guests can access to the public_data dataset without time constraints.\nWe define two datasets (confidential_data and public_data).\nThe current time is simulated to illustrate temporal limitations.\nExample queries demonstrate how Prolog can be used to check if a user has access to a specific dataset at the current time based on the defined rules.\nNote: The Axone SDK contains templates of governance rules that you can use and adapt to your needs."}),"\n",(0,i.jsx)(n.p,{children:"As we delve deeper into the Axone Academy, understanding the intricacies of resource rules becomes paramount. These rules serve as the backbone of the protocol, ensuring that off-chain resources are governed with precision, flexibility, and transparency. Join us as we unravel the complexities of resource rule management within the dynamic landscape of Axone."}),"\n",(0,i.jsx)(t.Z,{quiz:o})]})}function m(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},15251:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/rules-1-5dcbc47c61cb2699c0d72a3b5a26f6f9.webp"},48845:(e,n,s)=>{s.d(n,{Z:()=>i});const i=s.p+"assets/images/rules-2-7250d892179f44eb569b1e18677a3109.webp"}}]);